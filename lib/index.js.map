{"version":3,"file":"index.js","sources":["../src/index.js"],"sourcesContent":["/* global QUnit, window, __coverage__ */\n\nconst chalk = require(\"chalk\");\nconst istanbul = require(\"istanbul\");\nconst path = require(\"path\");\nconst puppeteer = require(\"puppeteer\");\nconst _ = require(\"lodash\");\nconst fs = require(\"fs-extra\");\nconst glob = require(\"glob\");\n\nconst { getBranchCoverage, getFunctionCoverage, getStatementCoverage } = require(\"./coverage-parser\");\n\nconst Category = {\n\tCREATED: \"\\uFF0B\",\n\tFAILURE: \"\\u2717\",\n};\n\nconst getCategoryColor = category => {\n\tswitch (category) {\n\t\tcase Category.CREATED: {\n\t\t\treturn \"green\";\n\t\t}\n\t\tcase Category.FAILURE: {\n\t\t\treturn \"red\";\n\t\t}\n\t\tdefault: {\n\t\t\treturn \"white\";\n\t\t}\n\t}\n};\n\nconst spreadObjectIf = (condition, element) => (condition ? element : {});\n\nconst defaults = {\n\ttimeout: 20000,\n\tformats: [],\n\toutput: process.cwd(),\n\tpuppeteerOptions: {},\n\tverbose: false,\n};\n\nconst qunitChromeRunner = (\n\tfilePath,\n\t{\n\t\tcoverage = { output: defaults.output, formats: defaults.formats },\n\t\tverbose = defaults.verbose,\n\t\ttimeout = defaults.timeout,\n\t\tpuppeteerOptions = defaults.puppeteerOptions,\n\t} = {},\n) => {\n\tconst fixturePath = `file:///${path.join(path.isAbsolute(filePath) ? \"\" : process.cwd(), filePath).replace(/\\\\/g, \"/\")}`;\n\tconst fixture = path.join(path.isAbsolute(filePath) ? \"\" : process.cwd(), filePath);\n\tconst fixtureName = path.basename(fixture, \".html\");\n\tconst snapshotDir = path.join(path.dirname(fixture), \"__snapshots__\", fixtureName);\n\n\tconst log = (...val) => {\n\t\tif (verbose) {\n\t\t\tconsole.log(...val);\n\t\t}\n\t};\n\n\t//\toptions:\n\t//\t\ttimeout\n\t//\t\tverbose\n\t//\t\tpuppeteerOptions: { /* options to pass to puppeteer */ }\n\t//\t\t`coverage: { output: \"...\", formats: [\"json\", ...] }` OR `coverage: false`\n\n\treturn new Promise((resolve, reject) => {\n\t\t(async () => {\n\t\t\tconst closeBrowser = async (browser, rejection) => {\n\t\t\t\ttry {\n\t\t\t\t\tbrowser.on(\"disconnected\", () => {\n\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\tconst { pid } = browser.process();\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tprocess.kill(pid);\n\t\t\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\t\t\tif (ex) {\n\t\t\t\t\t\t\t\t\tlog(`Failed to kill process: ${ex}`);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\tif (rejection) {\n\t\t\t\t\t\t\t\t\treject(rejection);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, 100);\n\t\t\t\t\t});\n\n\t\t\t\t\tbrowser.disconnect();\n\t\t\t\t} catch (ex) {\n\t\t\t\t\t// Silently handle, for now.\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tlog(\"Testing\", chalk.magenta(fixturePath));\n\n\t\t\tconst browser = await puppeteer.launch(puppeteerOptions);\n\t\t\tconst page = await browser.newPage();\n\t\t\tconst failures = [];\n\t\t\tconst messages = [];\n\n\t\t\t// Setting our timeout in case everything below takes too long\n\t\t\tconst timer = setTimeout(() => {\n\t\t\t\tlog();\n\t\t\t\tlog(chalk.red(\"Timeout exceeded.\"));\n\t\t\t\tlog();\n\n\t\t\t\tcloseBrowser(browser, new Error(\"Timeout exceeded\"));\n\t\t\t}, timeout || defaults.timeout);\n\n\t\t\ttry {\n\t\t\t\tawait page.exposeFunction(\"snapshotCreated\", async (assert, scope, id) => {\n\t\t\t\t\tmessages.push(_.extend({}, { category: Category.CREATED, message: `Snapshot \\`${id}\\` did not exist, so it was created.` }, assert));\n\t\t\t\t});\n\t\t\t} catch (ex) {\n\t\t\t\tlog(ex.message);\n\t\t\t\t// Silently handle, for now.\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tawait page.exposeFunction(\"logAssertion\", async response => {\n\t\t\t\t\t// Don't log if the test passed or it's a todo test\n\t\t\t\t\tif (!response.result && !response.todo) {\n\t\t\t\t\t\tfailures.push(_.extend({}, response, { category: Category.FAILURE }));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} catch (ex) {\n\t\t\t\t// Silently handle, for now.\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst saveSnapshots = snapshots => {\n\t\t\t\t\tfs.ensureDirSync(snapshotDir);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tObject.entries(snapshots).forEach(([scope, snaps]) => {\n\t\t\t\t\t\t\tconst file = path.join(snapshotDir, scope + \".snap\");\n\t\t\t\t\t\t\tconst existing = fs.existsSync(file) ? require(file) : {};\n\t\t\t\t\t\t\tconst snapshotFile = _.extend({}, existing, snaps);\n\n\t\t\t\t\t\t\tconst str = Object.entries(snapshotFile).reduce((fileStr, [key, value]) => {\n\t\t\t\t\t\t\t\treturn fileStr + \"module.exports[`\" + key + \"`] = `\\n\" + value.trim() + \"\\n`;\\n\\n\";\n\t\t\t\t\t\t\t}, \"\");\n\n\t\t\t\t\t\t\tfs.writeFileSync(file, str);\n\t\t\t\t\t\t});\n\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\t// TODO: Since this is an experimental feature, still need to figure out logging / error handling.\n\t\t\t\t\t\tconsole.error(ex);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tawait page.exposeFunction(\"report\", async (snapshots, response) => {\n\t\t\t\t\tlet coverageReport = {};\n\n\t\t\t\t\tif (snapshots) {\n\t\t\t\t\t\tsaveSnapshots(snapshots);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (coverage) {\n\t\t\t\t\t\tconst coverageResults = await page.evaluate(() => __coverage__);\n\t\t\t\t\t\tconst collector = new istanbul.Collector();\n\t\t\t\t\t\tconst reporter = new istanbul.Reporter(false, coverage.output || defaults.output);\n\t\t\t\t\t\tconst formats = coverage.formats || defaults.formats;\n\n\t\t\t\t\t\tif (verbose && !formats.includes(\"text-summary\")) {\n\t\t\t\t\t\t\tformats.push(\"text-summary\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcoverageReport = Object.assign({}, coverageReport, {\n\t\t\t\t\t\t\tbranch: getBranchCoverage(coverageResults),\n\t\t\t\t\t\t\tfunction: getFunctionCoverage(coverageResults),\n\t\t\t\t\t\t\tstatement: getStatementCoverage(coverageResults),\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tcollector.add(coverageResults);\n\n\t\t\t\t\t\treporter.addAll(formats);\n\t\t\t\t\t\treporter.write(collector, true, () => {\n\t\t\t\t\t\t\tif (!formats.includes(\"text-summary\") || formats.length !== 1) {\n\t\t\t\t\t\t\t\tlog();\n\t\t\t\t\t\t\t\tlog(`Coverage written to ${chalk.magenta(coverage.output)}`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tlog();\n\n\t\t\t\t\t// Group our failures by module / test\n\t\t\t\t\tconst grouped = _.forIn(_.groupBy(failures.concat(messages), failure => failure.module), (val, key, obj) => {\n\t\t\t\t\t\t// eslint-disable-next-line no-param-reassign\n\t\t\t\t\t\tobj[key] = _.groupBy(val, failure => failure.name);\n\t\t\t\t\t});\n\n\t\t\t\t\t// Loop through each module\n\t\t\t\t\t_.forIn(grouped, (val, key) => {\n\t\t\t\t\t\tconst hasModule = !!key;\n\n\t\t\t\t\t\tif (hasModule) {\n\t\t\t\t\t\t\tlog(key);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Loop through each test\n\t\t\t\t\t\t_.forIn(val, (tests, name) => {\n\t\t\t\t\t\t\tconst indent = hasModule ? \"  \" : \"\";\n\n\t\t\t\t\t\t\tlog(indent + name);\n\n\t\t\t\t\t\t\t// Print each failure\n\t\t\t\t\t\t\ttests.forEach(({ message, expected, actual, category }) => {\n\t\t\t\t\t\t\t\tif (message) {\n\t\t\t\t\t\t\t\t\tmessage = message.replace(/\\n/g, \"\\n\" + indent + \"      \");\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tlog(chalk[getCategoryColor(category)](`${indent}  ${chalk.bold(category)} ${message ? chalk.gray(message) : \"Test failure\"}`));\n\n\t\t\t\t\t\t\t\tif (!_.isUndefined(actual)) {\n\t\t\t\t\t\t\t\t\tlog(`${indent}      expected: ${expected}, actual: ${actual}`);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tlog();\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\n\t\t\t\t\t// messages.forEach(message => {\n\t\t\t\t\t// \tlog(chalk[getCategoryColor(message.category)].bold(message.category), chalk.gray(message.message, message.assert.moduleId));\n\t\t\t\t\t// });\n\n\t\t\t\t\tlog(chalk.blue(`Took ${response.runtime}ms to run ${response.total} tests. ${response.passed} passed, ${response.failed} failed.\\n`));\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait closeBrowser(browser);\n\n\t\t\t\t\t\t// Get rid of our timeout timer because we're done\n\t\t\t\t\t\tclearTimeout(timer);\n\n\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\tObject.assign(\n\t\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\t\t{ pass: !response.failed, results: _.omit(Object.assign({}, response), \"runtime\") },\n\t\t\t\t\t\t\t\tspreadObjectIf(coverage, {\n\t\t\t\t\t\t\t\t\tcoverage: coverageReport,\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\t// This might happen if the timeout exceeded and we already closed.\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} catch (ex) {\n\t\t\t\t// silently handle, for now\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tpage.on(\"load\", async () => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst qunitMissing = await page.evaluate(() => typeof QUnit === \"undefined\" || !QUnit);\n\n\t\t\t\t\t\tif (qunitMissing) {\n\t\t\t\t\t\t\tlog();\n\t\t\t\t\t\t\tlog(chalk.red(\"Unable to find the QUnit object.\"));\n\t\t\t\t\t\t\tlog();\n\n\t\t\t\t\t\t\tawait closeBrowser(browser, new Error(\"Unable to find the QUnit object\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\t// silently handle, for now\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait page.exposeFunction(\"loadSnapshots\", async () => {\n\t\t\t\t\t\t\tawait fs.ensureDir(snapshotDir);\n\n\t\t\t\t\t\t\tconst files = glob.sync(path.join(snapshotDir, \"*.snap\"));\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\treturn files.reduce((allSnapshots, file) => {\n\t\t\t\t\t\t\t\t\tconst snapshots = require(file) || {};\n\t\t\t\t\t\t\t\t\tconst scope = path.basename(file, \".snap\");\n\n\t\t\t\t\t\t\t\t\tconst scoped = Object.entries(snapshots).reduce((existing, [key, value]) => {\n\t\t\t\t\t\t\t\t\t\treturn _.extend({}, existing, { [key]: value.trim() });\n\t\t\t\t\t\t\t\t\t}, {});\n\n\t\t\t\t\t\t\t\t\treturn _.extend({}, allSnapshots, { [scope]: scoped });\n\t\t\t\t\t\t\t\t}, {});\n\t\t\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\t\t\t// TODO: Since this is an experimental feature, still need to figure out logging / error handling.\n\t\t\t\t\t\t\t\tconsole.error(ex);\n\t\t\t\t\t\t\t\treturn {};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tawait page.evaluate(async () => {\n\t\t\t\t\t\t\tconst storage = await window.loadSnapshots();\n\n\t\t\t\t\t\t\tconst saveSnapshot = (scope, id, snapshot) => {\n\t\t\t\t\t\t\t\tsnapshot = snapshot.trim();\n\t\t\t\t\t\t\t\tconst group = window.__snapshots__.storage[scope];\n\t\t\t\t\t\t\t\tconst scoped = Object.assign({}, group, { [id]: snapshot });\n\n\t\t\t\t\t\t\t\twindow.__snapshots__.storage[scope] = scoped;\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\twindow.__snapshots__ = {\n\t\t\t\t\t\t\t\tstorage,\n\t\t\t\t\t\t\t\tget(scope, id) {\n\t\t\t\t\t\t\t\t\tconst scoped = window.__snapshots__.storage[scope] || {};\n\n\t\t\t\t\t\t\t\t\treturn scoped[id];\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tcreate(assert, scope, id, snapshot) {\n\t\t\t\t\t\t\t\t\tsaveSnapshot(scope, id, snapshot);\n\t\t\t\t\t\t\t\t\twindow.snapshotCreated({ module: assert.test.module.name, name: assert.test.testName }, scope, id);\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tset: saveSnapshot,\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tQUnit.done(response => window.report(window.__snapshots__.storage, response));\n\t\t\t\t\t\t\tQUnit.log(window.logAssertion);\n\t\t\t\t\t\t\tQUnit.start();\n\t\t\t\t\t\t});\n\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\t// silently handle, for now.\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} catch (ex) {\n\t\t\t\t// silently handle, for now\n\t\t\t}\n\n\t\t\t// Navigate to our test file\n\t\t\ttry {\n\t\t\t\tawait page.goto(fixturePath);\n\t\t\t} catch (ex) {\n\t\t\t\tlog();\n\t\t\t\tlog(chalk.red(\"Failed to open the test file.\"));\n\t\t\t\tlog();\n\n\t\t\t\tawait closeBrowser(browser, new Error(\"Failed to open the test file.\"));\n\t\t\t}\n\t\t})();\n\t});\n};\n\nmodule.exports = qunitChromeRunner;\n"],"names":["const","chalk","require","istanbul","path","puppeteer","_","fs","glob","Category","getCategoryColor","category","spreadObjectIf","condition","element","defaults","timeout","formats","output","process","cwd","puppeteerOptions","verbose","module","exports","filePath","ref","fixturePath","join","isAbsolute","replace","fixture","fixtureName","basename","snapshotDir","dirname","log","console","val","Promise","resolve","reject","closeBrowser","browser","rejection","on","setTimeout","kill","pid","ex","disconnect","magenta","launch","then","$await_15","newPage","page","$await_16","failures","messages","timer","red","Error","exposeFunction","ensureDir","files","sync","reduce","allSnapshots","file","snapshots","scope","scoped","Object","entries","existing","extend","trim","error","evaluate","window","loadSnapshots","saveSnapshot","id","snapshot","group","__snapshots__","storage","assign","$await_19","get","create","assert","snapshotCreated","test","name","testName","set","QUnit","done","response","report","logAssertion","start","$await_21","goto","saveSnapshots","ensureDirSync","forEach","existsSync","snapshotFile","snaps","str","fileStr","writeFileSync","coverageReport","coverage","__coverage__","coverageResults","$await_25","collector","Collector","reporter","Reporter","includes","push","branch","getBranchCoverage","function","getFunctionCoverage","statement","getStatementCoverage","add","addAll","write","length","grouped","forIn","groupBy","concat","failure","key","obj","hasModule","tests","indent","message","bold","gray","isUndefined","actual","expected","blue","clearTimeout","pass","failed","results","omit","result","todo"],"mappings":"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"}